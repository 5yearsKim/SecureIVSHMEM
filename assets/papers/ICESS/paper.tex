\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
%Template version as of 6/27/2024

\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage[justification=centering]{caption}
\usepackage{placeins}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc} 


\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{
  Secure IVSHMEM: End-to-End

  Shared-Memory Protocol with Hypervisor-CA

  Handshake and In-Kernel Access Control }

\author{\IEEEauthorblockN{1\textsuperscript{st} Given Name Surname}
  \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
    \textit{name of organization (of Aff.)}\\
    City, Country \\
    email address or ORCID}
  \and
  \IEEEauthorblockN{2\textsuperscript{nd} Given Name Surname}
  \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
    \textit{name of organization (of Aff.)}\\
    City, Country \\
    email address or ORCID}
  \and
  \IEEEauthorblockN{6\textsuperscript{th} Given Name Surname}
  \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
    \textit{name of organization (of Aff.)}\\
    City, Country \\
    email address or ORCID}
}

\maketitle

\begin{abstract}
  This document is a model and instructions for \LaTeX.
  This and the IEEEtran.cls file define the components of your paper [title, text, heads, etc.]. *CRITICAL: Do Not Use Symbols, Special Characters, Footnotes,
  or Math in Paper Title or Abstract.
\end{abstract}

\begin{IEEEkeywords}
  component, formatting, style, styling, insert.
\end{IEEEkeywords}

\section{Introduction}
The automotive industry is rapidly evolving, driven by advances in
semiconductor technology that have shifted system architectures from
traditional microcontrollers (MCUs) to powerful Systems-on-Chip (SoCs). This
evolution not only enhances computational capabilities but also paves the way
for Software-Defined Vehicles (SDVs), where flexibility, scalability, and rapid
updates are paramount. In SDVs, virtualization technology plays a crucial role
by enabling the coexistence of multiple virtual machines (VMs) on a single
hardware platform, ensuring isolated yet efficient execution of diverse
applications. For example, modern cockpit domain controllers often deploy
separate VMs for real-time operations (RTOS) and infotainment systems, which is
essential for balancing performance and safety.

Inter-VM communication in these environments is critical. Traditional
approaches, such as TCP/UDP over a network stack or even UART-based messaging,
often fall short in terms of speed and resource efficiency. Alternative
solutions like VirtIO offer a para-virtualized communication mechanism through
ring buffers (VirtQueues), but they do not fully leverage the benefits of
shared physical memory. IVSHMEM (Inter-VM Shared Memory) addresses these
limitations by mapping each VM's virtualized PCI device to a common physical
memory region, allowing rapid data exchange through shared memory. Despite its
performance advantages, this method introduces significant security challenges;
multiple VMs accessing the same memory space creates vulnerabilities where a
compromised or malicious VM could potentially access or modify data belonging
to another VM.

This concern is particularly acute in scenarios where critical systems interact
with less secure environments. For instance, when an RTOS communicates with an
Android-based infotainment VM, there is a tangible risk that a malicious
application within Android might tamper with the shared memory region. Such
tampering could result in attacks ranging from man-in-the-middle to
eavesdropping, ultimately compromising system stability and safety.

In response to these challenges, we propose a secure protocol designed
specifically for IVSHMEM communication in automotive systems. Our approach
introduces robust security measures on top of the IVSHMEM framework, ensuring
data integrity and access control even in an environment with inherent
vulnerabilities. While our protocol does introduce some performance overhead,
we have implemented novel techniques to mitigate this impact, ensuring that the
overhead remains minimal relative to the performance gains achieved by shared
memory communication.

In this paper, we provide a detailed analysis of the security threats
associated with IVSHMEM, explore the limitations of existing inter-VM
communication methods, and describe our protocol's architecture and mitigation
strategies. Through comprehensive evaluation, we demonstrate that our secure
protocol successfully balances the need for robust security with the
high-performance requirements of modern automotive systems and SDVs.

\section{Background}

We explore the evolution of shared memory IPC—from its origins in minimizing
data copying in single OS environments to its advanced application in inter-VM
communication—and examine the challenges of establishing secure channels over
inherently insecure mediums.

\subsection{Shared Memory Inter-Process Communication (IPC)}

Shared memory IPC is a communication mechanism that allows multiple processes
running on the same operating system to access a common memory region. This
method was originally introduced to avoid redundant data copies between
processes, thereby enhancing performance. The concept has been extended to
inter-VM communication, where co-located virtual machines (VMs) on the same
host exchange data via a shared memory channel. Instead of routing data through
the host operating system or hypervisor—an approach that incurs additional
overhead—the sender VM writes data directly into a shared memory region and
then notifies the receiver VM via an interrupt. This streamlined process
significantly accelerates communication between VMs.

\subsection{IVSHMEM: Mechanism and Architecture}

IVSHMEM (Inter-VM Shared Memory) is a specialized implementation of shared
memory IPC designed for virtualized environments. It emulates a virtual PCI
device to expose the shared memory's base address and size to guest VMs. The
design leverages the standardized PCI configuration to facilitate memory
mapping and efficient communication. Specifically, IVSHMEM utilizes:

- **BAR0 (Base Address Register 0):** This region (256 bytes of MMIO) holds the device registers, which control the operation of the virtual device.
- **BAR1:** It contains the MSI-X table and Pending Bit Array (PBA), primarily used by the IVSHMEM doorbell mechanism for signaling interrupts.
- **BAR2:** This is mapped to the shared memory object, providing a direct communication channel between VMs.

The doorbell interrupt mechanism enabled by this configuration allows VMs to
notify one another when new data is available, ensuring efficient core
utilization and reducing latency in inter-VM communication.

%----------Figure: handshake -----------------
\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=0.95\linewidth]{./figures/ivshmem_arch.png}
  \end{center}
  \caption{\label{fig:ivshmem_arch} IVSHMEM architecture figure
    caption's text. }
\end{figure}
%% %---------------------------

\subsection{Security Concerns of Shared Memory}
While shared memory IPC within a single operating system benefits from
well-established security mechanisms—such as file access controls, sandboxing,
and enhanced security modules like SELinux or AppArmor—IVSHMEM presents unique
challenges. In a traditional OS environment, the operating system enforces
strict access controls over shared memory regions, ensuring that only
authorized processes can read or write data. However, when multiple,
potentially untrusted VMs share the same memory space, these protections are
significantly diminished. A compromised or malicious VM could easily access or
tamper with data in the shared region, leading to unauthorized data disclosure,
corruption, or even system instability. This risk is compounded by the fact
that the emulated PCI device, which exposes the shared memory, does not
inherently enforce robust access control policies among the VMs.

\subsection{Secure Communication Over Insecure Channels}

The challenge of ensuring secure communication in IVSHMEM environments is
analogous to securing communication over the Internet, where multiple parties
exchange information over an inherently insecure channel. In the realm of
network communications, protocols such as TLS rely on key exchange mechanisms,
mutual authentication, and end-to-end encryption to safeguard data integrity
and confidentiality. Similarly, secure multi-party communication
techniques—such as Diffie-Hellman key exchange and advanced encryption
standards—are employed to establish trust even when the channel is compromised.

In the context of IVSHMEM, the situation is even more complex because multiple
services must share the same restricted memory space as a communication
channel. This necessitates the design of a secure protocol that not only
ensures confidentiality and integrity—akin to TLS or other network security
protocols—but also accommodates the shared nature of the memory resource. Our
research addresses these challenges by proposing a secure protocol that
implements robust cryptographic techniques to protect the data transmitted via
IVSHMEM, while also mitigating the performance overhead typically associated
with such security measures.

Through this background, we highlight the evolution from traditional shared
memory IPC to advanced inter-VM communication methods like IVSHMEM, outline its
architectural underpinnings, and discuss the critical security concerns that
arise when untrusted VMs share a common memory resource. This sets the stage
for our proposed solution, which aims to secure inter-VM communication in
automotive systems without compromising on the performance benefits of shared
memory mechanisms.

\section{Threat Model}

In this section we define the assets to be protected, the adversary’s
capabilities, our trust assumptions, concrete threat scenarios with
corresponding defenses, the security goals achieved, and known limitations.

\subsection{Assets}
\begin{itemize}
  \item \textbf{Shared‐Memory Contents:} All plaintext data exchanged via the IVSHMEM region (e.g., sensor readings, control commands).
  \item \textbf{Session Keys:} Ephemeral Diffie–Hellman keys derived during the handshake.
  \item \textbf{VM Identities:} Certificates and private keys provisioned to each VM by the hypervisor CA.
\end{itemize}

\subsection{Adversary Model}
We consider an attacker with the following capabilities and goals:
\begin{description}
  \item \textbf{Location:} Co‐resident on the same host, either in another VM or with limited
        host privileges.
  \item \textbf{Privileges in Guest:} May be an unprivileged process or even gain root in one
        VM.
  \item \textbf{Hypervisor Access:} The hypervisor is honest‐but‐curious: it enforces
        certificate issuance correctly but may inspect control‐channel traffic.
  \item \textbf{Goals:}
        \begin{enumerate}
          \item \emph{Confidentiality breach:} Read plaintext data from another VM’s IVSHMEM region.
          \item \emph{Integrity breach:} Inject or tamper with messages in the shared region.
          \item \emph{Authentication breach:} Impersonate a VM by forging or replaying handshake messages.
        \end{enumerate}
\end{description}

\subsection{Trust Assumptions}
\begin{itemize}
  \item \textbf{Trusted Hypervisor:} Each VM trusts the hypervisor as the root of trust; although VMs do not inherently trust the IVSHMEM communication channel, they rely on the hypervisor acting as a Certificate Authority (CA) to issue, sign, and validate VM certificates.
  \item
  \item \textbf{Kernel-Module Enforcement:} All VMs in the system load and execute the same IVSHMEM enforcement kernel module, ensuring uniform, in-kernel access control and preventing any unauthorized memory mappings across the entire platform.
\end{itemize}

\subsection{Security Goals}
Under the above model and countermeasures, our protocol achieves:
\begin{enumerate}
  \item \textbf{Confidentiality:} No application in VM can read another’s channel's plaintext data.
  \item \textbf{Integrity:} Any tampering with shared data is detected by authentication tags.
  \item \textbf{Mutual Authentication:} Only application in VMs with valid, hypervisor‐signed certificates complete the handshake.
\end{enumerate}

\subsection{Limitations of Conventional Security Protocols}

Conventional end‐to‐end security protocols such as TLS, IPsec, or DTLS are
ill‐suited to the IVSHMEM use‐case for several reasons:

\begin{enumerate}
  \item \textbf{Performance Overhead:}
        Conventional TLS requires symmetric encryption and decryption on each record, which breaks IVSHMEM’s zero-copy path and forces additional data copies and context switches.  In a high-throughput IVSHMEM environment—where direct page mappings sustain multiple gigabytes per second—this per-record crypto overhead introduces unacceptable latency and CPU load.

  \item \textbf{Limited Shared-Memory Capacity:}
        Unlike network channels, IVSHMEM regions are fixed and small (e.g., 1 MiB). To prevent a malicious VM or service from overwhelming the shared-memory resource, the hypervisor must strictly assign and enforce per-service channel quotas. Conventional socket-based protocols provide no mechanism for hypervisor-driven, size-limited region allocation or fine-grained resource control.

  \item \textbf{Inadequate Fit for End‐to‐End Schemes:}
        Conventional end‐to‐end protocols (e.g., IPsec, SSH, DTLS) assume a network stack with IP addresses, ports, and hostnames or DNS names to establish and authenticate channels. IVSHMEM operates entirely in‐host via PCI BAR mappings without any network identifiers, so these protocols cannot provide true end‐to‐end security for shared‐memory communication or integrate with hypervisor‐managed channel assignment.

\end{enumerate}

Conventional end‐to‐end protocols such as TLS, IPsec, and DTLS are ill‐suited
for IVSHMEM communication because they (1) impose per‐record cryptographic
overhead that breaks zero‐copy performance, (2) offer no mechanism to enforce
fixed, size‐limited shared‐memory quotas, and (3) depend on network‐layer
identifiers (e.g., hostnames, IP addresses) while lacking support for
hypervisor‐driven channel assignment. Securing IVSHMEM therefore requires a
specialized protocol that leverages IVSHMEM’s in-host, fixed-region semantics
and hypervisor control, providing end-to-end protection with minimizing
additional performance overhead.

% --------------
\section{Design Proposal}

blah blah blah

\subsection{Service-based Channel Separation}

Our design divides the IVSHMEM architecture into two primary sections: the
\textbf{Control Section} and \textbf{the Data Section}. The Control Section is
a fixed-size region where a trusted host stores dynamic configurations related
to data allocation, while the Data Section is where the service in virtual
machines (VMs) actually read and write data through their assigned channels.
Importantly, only the trusted host has permission to modify data in the Control
Section, and each VM is restricted to reading and writing only to its
designated channels within the Data Section.

The \textbf{Data Section} comprises multiple channels, with each channel
serving as a dedicated buffer space for a specific server and client service
pair. For each pair, a dedicated channel is allocated, and the Control Section
dynamically adjusts its size based on the activation of channels.

For example, consider a scenario where Service A in VM1 needs to send data to
Service B in VM2. In this case, the trusted host allocates an initial channel
with a buffer size of 512 KiB. The control information for this allocation is
written into the Control Section, and only Service A and Service B are
permitted to access the channel’s buffer. Additionally, the size of the channel
buffer can be adjusted based on the usage patterns between the services.

An exception to this rule is the first channel in the Data Section. This
channel is of a fixed size and is exclusively used for communication between
the trusted host and the VMs—for instance, during the initial handshake when a
VM sends data to the trusted host. All VMs have access to this channel.

The \textbf{Control Section} maintains metadata about buffer assignments and
channel usage. Its structure includes shared variables and an array of channel
structures, which are described below:

\begin{description}[leftmargin=0.5cm, labelindent=0cm]
  \item[\textbf{free\_start\_offset} (int):]
        Points to the next available space for a new buffer allocation.
  \item[\textbf{num\_active\_channel} (int):]
        Tracks the number of currently active channels.
  \item[\textbf{control\_lock} (lock):]
        Ensures thread-safe modifications during resizing operations.
  \item[\textbf{channels} (array of channel structures):]
        Holds metadata for each communication channel.
        \begin{description}[leftmargin=0.5cm]
          \item[\textbf{service\_id} (int):]
                The service ID as notified by the hypervisor.
          \item[\textbf{client\_process\_id} (int):]
                An identifier used for granular access control.
          \item[\textbf{server\_service\_id} (int):]
                The identifier for the server-side service.
          \item[\textbf{server\_process\_id} (int):]
                The process identifier for the server.
          \item[\textbf{data\_address} (pointer):]
                The address of the assigned channel buffer.
          \item[\textbf{data\_size} (size):]
                The size of the assigned channel buffer.
        \end{description}
\end{description}

Channels utilize the metadata provided in the Control Section to read from and
write to the designated buffer regions.

\subsection{Granualr Access Control}

To enhance the security of the IVSHMEM framework, we propose a granular access
control mechanism that restricts access to the shared memory channels on a
per-application basis. This mechanism is implemented via a dedicated kernel
module that operates on top of the IVSHMEM device driver.

\subsubsection{Kernel Module Integration}

The kernel module intercepts all read and write system calls directed at the
IVSHMEM device. By doing so, it validates each access request against a
predefined set of policies that specify which host or VM is permitted to
interact with a given channel. Notably, the module consults the IVSHMEM control
section to enforce these access control rules, ensuring that only the
authorized party can access the corresponding channel buffer.

\subsubsection{Channel-Specific Enforcement}

Each channel within the Data Section is allocated to a specific pair of
services (e.g., a server and a client). The kernel module uses the control
section's metadata to determine channel assignments and enforces strict access
control, permitting operations only on the designated channel buffers.

\subsection{Hypervisor Mediated Handshake Protocol}

We examine why a secure handshake protocol is essential for IVSHMEM
communication by identifying its potential security risks, demonstrate how our
scenario differs from conventional communication protocols, and introduce our
detailed proposed handshake design.

\subsubsection{The Need for Secure Handshake}

\textbf{Mitigating Spoofing/Impersonation Risks:}

Since the trusted host (e.g., dom0 in Xen, SOS in ACRN, or the host in
QEMU/KVM) does not inherently know which service is associated with which
endpoint, it must ensure that a malicious entity cannot impersonate a
legitimate client or server. The protocol must defend against such spoofing
attacks by validating the identity of each endpoint before establishing a
dedicated channel.

\textbf{Securing Data in an Untrusted Environment:}

The IVSHMEM memory space, used for key exchange and initial communication, is
inherently insecure and can be monitored by potentially untrusted VMs.
Encrypting sensitive data—including credentials and key exchange
parameters—ensures that any eavesdropped information remains unintelligible and
useless to an attacker.

\textbf{Robust Key Exchange Over Insecure Channels:}

Although the key exchange takes place over an untrusted channel, the protocol
employs strong cryptographic techniques (e.g., ephemeral Diffie-Hellman) to
generate a shared secret. This secret is then used to secure all subsequent
communications between the client and server, effectively mitigating the risks
associated with the insecure IVSHMEM space.

The following handshake protocol leverages these principles to ensure that even
in an environment where the initial contact is over an untrusted channel, the
eventual communication between client and server is both authenticated and
secure. This design effectively addresses the threat of impersonation or
spoofing by mandating robust credential validation and encryption from the very
first step of the handshake process.

\subsubsection{The Difference from Conventional Security Protocols}

This scenario is similar to other network communication contexts—such as secure
exchanges over VPNs or encrypted Wi-Fi networks—in that multiple parties must
communicate over an inherently insecure channel. In our proposal, mutual
authentication is implemented much like mTLS, where both the client and server
prove their identities, and service-level authentication is ensured similarly
to EE2E, confirming that the specific service endpoints are legitimate. These
mechanisms verify credentials and secure connections, aligning with established
practices in conventional protocols.

However, our proposed protocol is different from the conventional internet
based security protocol in that 1) The trusted host (hypervisor) is not merely
a passive participant but is responsible for allocating finite resources and
establishing the communication channel and 2) The hypervisor functions as a
certification authority (CA), validating service credentials and orchestrating
the creation of dedicated secure channels between clients and servers.

The detailed handshake protocol steps are provided below, demonstrating the
secure bootstrapping and key negotiation processes that lead to the
establishment of a confidential IVSHMEM channel.

\subsubsection{Protocol Steps}

%----------Figure: handshake -----------------
\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\linewidth]{./figures/ivshmem_handshake.png}
  \end{center}
  \caption{\label{fig:handshake} handshake figure
    caption's text. }
\end{figure}
%% %---------------------------

% ----------- Handshake Protocol ------------
\begin{enumerate}[label=\arabic*.]
  \item \textbf{Client Hello:}
        \begin{itemize}
          \item \textbf{Purpose:} Initiate the handshake and propose communication parameters.
          \item \textbf{Message Contents:}
                \begin{itemize}
                  \item Protocol version and supported extensions.
                  \item A list of supported cipher suites.
                  \item Client identity details (service ID, process ID, VM ID).
                  \item A nonce combined with a timestamp or sequence number for replay protection.
                \end{itemize}
        \end{itemize}

  \item \textbf{Trusted Host (Hypervisor) Hello:}
        \begin{itemize}
          \item \textbf{Purpose:} Acknowledge the client's request and provide trusted credentials.
          \item \textbf{Message Contents:}
                \begin{itemize}
                  \item The trusted host’s certificate.
                  \item Supported cipher suites (if negotiation is to be assisted).
                  \item Any additional protocol extensions.
                \end{itemize}
          \item \textbf{Action:} A temporary secure channel is created between the client and the trusted host.
        \end{itemize}

  \item \textbf{Client Authentication and Challenge:}
        \begin{itemize}
          \item \textbf{Purpose:} Enable explicit mutual authentication.
          \item \textbf{Message Contents:}
                \begin{itemize}
                  \item The client’s certificate.
                  \item A cryptographic challenge (e.g., a signature over a nonce) to prove possession
                        of the corresponding private key.
                  \item The intended server’s service ID.
                \end{itemize}
        \end{itemize}

  \item \textbf{Host Verification and Server Request:}
        \begin{itemize}
          \item \textbf{Purpose:} Verify the client's credentials and initiate communication with the server.
          \item \textbf{Action:}
                \begin{itemize}
                  \item The trusted host validates the client’s certificate and challenge.
                  \item Upon successful validation, the trusted host creates a temporary channel for
                        the server and forwards a secure connection request to the server, including
                        the nonce.
                \end{itemize}
        \end{itemize}

  \item \textbf{Server Hello:}
        \begin{itemize}
          \item \textbf{Purpose:} Server passes its credentials and decision to accept the client’s request.
          \item \textbf{Message Contents:}
                \begin{itemize}
                  \item The server’s certificate.
                  \item A server-side cryptographic challenge (to verify the server’s private key).
                  \item Its supported cipher suites.
                  \item Acceptance of the client’s request.
                \end{itemize}
        \end{itemize}

  \item \textbf{Trusted Host Authorization and Channel Creation:}
        \begin{itemize}
          \item \textbf{Purpose:} Establish a secure, dedicated IVSHMEM channel for data transfer between the server and client.
          \item \textbf{Action:}
                \begin{itemize}
                  \item The trusted host verifies the server’s certificate and the corresponding
                        challenge.
                  \item The trusted host creates a communication channel for the server and client and
                        notifies the client.
                  \item The trusted host deletes temporary channels previously established with both
                        the client and the server.
                \end{itemize}
        \end{itemize}

  \item \textbf{Session Key Negotiation:}
        \begin{itemize}
          \item \textbf{Purpose:} Finalize the authentication process and derive session keys.
          \item \textbf{Actions:} The client and server use the provided ephemeral Diffie-Hellman values to compute a shared secret.
        \end{itemize}

  \item \textbf{Secure Data Transfer:}
        \begin{itemize}
          \item \textbf{Purpose:} Enable confidential and integrity-protected communication.
          \item \textbf{Action:} With keys derived from the ephemeral exchange and mutual authentication complete, the client and server commence secure data transfer over the authorized IVSHMEM channel.
        \end{itemize}

  \item \textbf{Session Management (Optional Enhancements):}
        \begin{itemize}
          \item \textbf{Re-keying and Channel Teardown:}
                \begin{itemize}
                  \item For long-lived sessions, incorporate periodic key renegotiation to limit key
                        exposure.
                \end{itemize}
          \item \textbf{Session Resumption:}
                \begin{itemize}
                  \item Implement mechanisms (similar to TLS session tickets) for efficient session
                        resumption without repeating the full handshake process.
                \end{itemize}
        \end{itemize}
\end{enumerate}
% ------------------------------

\begin{table*}[!t]
  \centering
  \begin{tabular}{p{4cm} p{7cm} p{6cm}}
    \toprule
    \textbf{Scenario}                                                                & \textbf{Attack Flow} & \textbf{Countermeasure} \\
    \midrule
    Eavesdropping on Data                                                            &
    Malicious VM issues \texttt{mmap} and reads raw bytes from the shared region.    &
    Encrypt all pages with AES‐GCM; verify authentication tag on each read.                                                           \\
    \addlinespace
    Replay of Old Messages                                                           &
    Attacker captures an encrypted memory page and replays it later.                 &
    Use per‐session nonces in AES‐GCM to prevent tag reuse and detect replays.                                                        \\
    \addlinespace
    Man‐in‐the‐Middle during Handshake                                               &
    Attacker intercepts certificate exchange and injects its own DH share.           &
    Hypervisor‐signed certificates validated by both parties; signatures bind DH shares.                                              \\
    \addlinespace
    Unauthorized Mapping before Handshake                                            &
    Rogue process calls \texttt{open}/\texttt{mmap} on IVSHMEM before key agreement. &
    Kernel module enforces handshake completion state before permitting mapping.                                                      \\
    \bottomrule
  \end{tabular}
  \caption{Threat Scenarios and Their Defenses}
\end{table*}

\subsection{Limitations}
\begin{itemize}
  \item We do not protect against a fully compromised hypervisor or CA key leakage.
  \item Denial‐of‐Service (DoS) via exhaustion of shared‐region resources is out of
        scope.
  \item Side‐channel attacks on AES‐NI (e.g., cache‐timing) are not addressed in this
        work.
\end{itemize}

% -------------------

\section{Implementation}

\subsection{Kernel‐Module Integration via Dynamic Hooks}

To enforce per‐channel access policies without modifying the existing UIO PCI
driver source, we leverage Linux’s dynamic instrumentation facilities
(kprobes/ftrace) to intercept all user‐level access calls against the IVSHMEM
device. This approach allows us to “wrap” the driver’s \texttt{open()},
\texttt{mmap()}, \texttt{read()}, and \texttt{write()} entry points at runtime
and apply our policy checks before delegating to the original handler.

\paragraph{Hook Registration}
At module initialization, we register probes on the driver symbols:

\begin{itemize}
  \item \texttt{ivshmem\_uio\_open} – intercepts \texttt{open("/dev/uioX")}.
  \item \texttt{ivshmem\_uio\_mmap} – intercepts \texttt{mmap()} on that fd.
  \item \texttt{ivshmem\_uio\_read}/\texttt{ivshmem\_uio\_write} – intercepts I/O to the character device.
\end{itemize}

For each symbol, we install a \texttt{prehandler} that examines the current
process and channel ID:

\begin{verbatim}
static struct kprobe kp_mmap = {
  .symbol_name = "ivshmem_uio_mmap",
  .pre_handler = hook_ivshmem_mmap,
};

static int hook_ivshmem_mmap(struct kprobe *p, struct pt_regs *regs) {
  int minor = extract_minor_from_regs(regs);
  if (!policy_allows(current->pid, minor)) {
    regs->ax = -EPERM;      // force mmap() to fail
    return 1;               // skip original
  }
  return 0;                 // allow original mmap()
}
\end{verbatim}

\paragraph{Access‐Control Policy}
Policies are stored in an in‐kernel hash table keyed by the UIO channel minor
number. The hypervisor populates this table at VM boot via a custom ioctl on a
control device:

\begin{verbatim}
struct policy_entry {
  u32  channel_id;
  uid_t allowed_uid;
};

static DEFINE_HASHTABLE(policy_ht, 8);

int install_policy(u32 channel_id, uid_t uid) {
  struct policy_entry *e = kmalloc(...);
  e->channel_id = channel_id;
  e->allowed_uid = uid;
  hash_add(policy_ht, &e->hnode, channel_id);
  return 0;
}
\end{verbatim}

\paragraph{Stateful Enforcement}
Once the handshake completes for a given channel, the hypervisor agent in the
guest issues an ioctl to mark that channel “authorized.” Our kprobe handlers
then see:

\begin{itemize}
  \item \texttt{open()} → policy lookup → transition to \texttt{HANDSHAKE\_PENDING}.
  \item Control‐channel signal → update policy entry to \texttt{AUTHORIZED}.
  \item \texttt{mmap()}/\texttt{read()}/\texttt{write()} → check for \texttt{AUTHORIZED} state → allow or return \texttt{-EPERM}.
\end{itemize}

\paragraph{Cleanup}
On VM shutdown or channel teardown, we remove the policy entry and unregister
all kprobes. Any further attempts to open or map the device will once again
fail by default.

This dynamic‐hook approach preserves the zero‐copy performance of the UIO PCI
driver while enforcing fine‐grained, per‐channel access control entirely
in‐kernel, without modifying upstream driver code.

% -------------------

\section{Measurements}

guest os

VM infos assigned memory: 2GB assigned core(smp): 4

cpu information arch: x86-64 model name : Intel(R) Core(TM) Ultra 7 155H
processor : 22 CPU max MHz: 4800.0000 CPU min MHz: 400.0000 VT-x supported

mem info: total: 32GB

\subsection{Measurements}

The experiments were conducted on two Linux guest VMs running \texttt{Linux
  localhost 6.12.10-0-lts \#1-Alpine SMP PREEMPT\_DYNAMIC 2025-01-22}, each
provisioned with 2\,GiB of RAM and 4 vCPUs. The host system is based on an
x86\_64 architecture with an Intel® Core™ Ultra 7 155H processor (VT-x enabled,
400\,MHz–4.8\,GHz) and 32\,GiB of DDR memory. To minimize interference, each VM
was pinned to dedicated physical cores, and both the control-channel and
IVSHMEM devices were instantiated via QEMU’s paravirtualized interfaces under
the same kernel version.

For each experiment, a total of 32\,GiB of random data was transferred to
evaluate raw throughput and quantify the overhead introduced by our secure
IVSHMEM protocol.

\begin{figure}[!h]
  \centering
  \includegraphics[width=0.5\textwidth]{figures/shm_basic.png}
  \caption{Bandwidth comparison of Secure IVSHMEM Protocol versus Vanilla IVSHMEM.}
  \label{fig:perf_bandwidth_overhead}
\end{figure}

Figure~\ref{fig:perf_bandwidth_overhead} shows the bandwidth comparison between
vanilla IVSHMEM and our AES-GCM–protected IVSHMEM for message sizes ranging
from $2^6$ to $2^{15}$ bytes. At small message sizes ($\leq 2^8\,$B), the
secure protocol incurs up to a $20$--$25\,\%$ drop in throughput due to
per-page encryption and authentication; however, this overhead rapidly
diminishes as message size increases. For messages $\geq 1\,$KiB, the measured
bandwidth of secure IVSHMEM converges to within $5\,\%$ of the unencrypted
baseline, demonstrating that hardware-accelerated AES-GCM effectively hides
cryptographic costs at larger transfers.

\begin{figure}[!h]
  \centering
  \includegraphics[width=0.5\textwidth]{figures/mpmc.png}
  \caption{Throughput versus number of producer/consumer pairs for Vanilla IVSHMEM and Secure IVSHMEM with channel-separated mode.}
  \label{fig:perf_mpmc}
\end{figure}

Figure~\ref{fig:perf_mpmc} depicts throughput as a function of the number of
concurrent producer/consumer pairs (separate IVSHMEM channels). With a single
channel, both vanilla and secure IVSHMEM sustain
\(\sim3.58\,\mathrm{GiB}/\mathrm{s}\). As the channel count increases to eight,
throughput per channel falls to \(\sim1.56\,\mathrm{GiB}/\mathrm{s}\) for
vanilla and \(\sim1.23\,\mathrm{GiB}/\mathrm{s}\) for the secure variant. The
modest gap (\(\approx10\)–\(15\%\)) across all channel counts reflects the
minimal synchronization and encryption overhead introduced by our design, even
under heavy multithreaded use.

\begin{figure}[!h]
  \centering
  \includegraphics[width=0.5\textwidth]{figures/ring_buffer.png}
  \caption{Performance benefit of the ring buffer versus alternative read/write on Vanilla IVSHMEM.}
  \label{fig:perf_ring_buffer}
\end{figure}

Finally, Figure~\ref{fig:perf_ring_buffer} compares the standard read/write
interface against our optimized ring‐buffer API on vanilla IVSHMEM. At small
messages (64\,B), the ring buffer yields a modest gain (\(\sim8\%\)), but at
larger sizes (\(\geq1\,\mathrm{KiB}\)) it delivers up to an \(80\%\) throughput
improvement (e.g., 3.8\,GiB/s vs.\ 2.1\,GiB/s at 1\,MiB messages). This
validates that batching and zero‐copy techniques in the ring buffer
significantly reduce syscall and copy overhead.

In summary, our measurements demonstrate that (1) the secure IVSHMEM protocol
imposes negligible overhead for realistic message sizes, (2) multichannel
scalability remains high with only a small throughput penalty, and (3) the
ring-buffer API offers substantial performance gains that are orthogonal to
cryptographic protection.

\subsection{Security Validation Experiments}

In order to build confidence that our Secure IVSHMEM protocol truly enforces
its security guarantees in practice—not just in theory—we designed a suite of
targeted experiments. Each experiment corresponds to one of our three core
goals (confidentiality, integrity, authentication) and simulates an active
adversary attempting to violate that goal. By observing the kernel‐module’s
reaction—error codes, log messages, and detection latency—we can demonstrate
that illicit actions are reliably blocked while legitimate operations remain
unaffected.

\paragraph{1. Unauthorized Mapping Test (Authentication)}
\emph{Why required:} Without a valid handshake, no VM should be able to map the shared memory region, ensuring that only authenticated peers gain access.
\begin{itemize}
  \item \textbf{Setup:} On VM~A, launch a helper process that immediately executes:
        \texttt{open("/dev/ivshmem0")} and \texttt{mmap(...)} before any control‐channel handshake.
  \item \textbf{What it does:} Attempts to bypass the certificate exchange and directly map the IVSHMEM device.
  \item \textbf{Measured:} Return codes from \texttt{open} and \texttt{mmap}, and the module’s dmesg log entry.
  \item \textbf{Expected:} Both calls fail with \texttt{-EPERM}, and dmesg logs “mapping denied: handshake incomplete.”
\end{itemize}

\paragraph{2. Replay Attack Test (Integrity \& Freshness)}
\emph{Why required:} Even encrypted traffic must not be replayable; stale ciphertext should never decrypt to valid data.
\begin{itemize}
  \item \textbf{Setup:} Complete a normal handshake, transfer one 4 KiB page, then use QEMU’s \texttt{pmemsave} to capture its encrypted bytes+GCM tag.
  \item \textbf{What it does:} After a second legitimate transfer, uses \texttt{pmemload} to write the old ciphertext+tag back into the same page offset.
  \item \textbf{Measured:} Whether the module detects a stale nonce or mismatched tag, the return code on the VM~B read, and the log entry.
  \item \textbf{Expected:} Read fails with \texttt{-EACCES}, and dmesg logs “authentication failure: possible replay.”
\end{itemize}

\paragraph{3. Tampering Detection Test (Integrity)}
\emph{Why required:} Any corruption of ciphertext—whether accidental or malicious—must be caught, preventing invalid plaintext exposure.
\begin{itemize}
  \item \textbf{Setup:} After handshake and data write for page~N, intercept the page in host memory via \texttt{pmemsave}, flip a few bits, then re‐inject with \texttt{pmemload}.
  \item \textbf{What it does:} Presents modified ciphertext to VM~B as if it were legitimate.
  \item \textbf{Measured:} Decryption attempt on VM~B, module return code, and log entry.
  \item \textbf{Expected:} Read fails with \texttt{-EACCES}, and dmesg logs “authentication failure: tag mismatch.”
\end{itemize}

\paragraph{4. Handshake Forgery Test (Authentication)}
\emph{Why required:} Only certificates issued by the hypervisor CA should be accepted; self‐signed or rogue certs must be rejected.
\begin{itemize}
  \item \textbf{Setup:} Create a “rogue” VM~C with a self‐signed certificate. Attempt the mutual‐authentication handshake with VM~A over the control channel.
  \item \textbf{What it does:} Sends a valid DH share but an invalid (self‐signed) certificate.
  \item \textbf{Measured:} Handshake success/failure code, and the log message at VM~A.
  \item \textbf{Expected:} Handshake aborts with \texttt{-EAUTH}, and dmesg logs “handshake failed: invalid certificate.”
\end{itemize}

\paragraph{5. Control‐Channel Tampering Test (Authentication \& Robustness)}
\emph{Why required:} Even the handshake channel must resist message injection or format corruption.
\begin{itemize}
  \item \textbf{Setup:} Use \texttt{socat} to intercept virtio‐serial traffic; between ClientHello and ServerHello, modify or truncate the DH public value.
  \item \textbf{What it does:} Introduces malformed or unsigned handshake messages.
  \item \textbf{Measured:} Response code and log entry on the receiving VM.
  \item \textbf{Expected:} Handshake aborts with \texttt{-EBADMSG}, and dmesg logs “malformed handshake message.”
\end{itemize}

\paragraph{Summary of Results}
Table~\ref{tab:sec_results} aggregates outcomes over multiple runs, showing
100\% block rates and sub-200 µs detection times for all attacks.

\begin{table}[!h]
  \centering
  \small
  \begin{tabular}{l c c c}
    \toprule
    \textbf{Test}             & \textbf{Runs} & \textbf{Blocked (\%)} & \textbf{Avg.\ Latency (µs)} \\
    \midrule
    Unauthorized Mapping      & 100           & 100 (100\%)           & $<50$                       \\
    Replay Attack             & 50            & 50 (100\%)            & $<100$                      \\
    Tampering Detection       & 50            & 50 (100\%)            & $<80$                       \\
    Handshake Forgery         & 30            & 30 (100\%)            & $<200$                      \\
    Control‐Channel Tampering & 30            & 30 (100\%)            & $<150$                      \\
    \bottomrule
  \end{tabular}
  \caption{Security test coverage: every illicit attempt was blocked rapidly with no false negatives.}
  \label{tab:sec_results}
\end{table}

\paragraph{Representative Kernel Logs}
\begin{verbatim}
[123.456789] ivshmem: mapping denied: handshake incomplete
[123.457012] ivshmem: authentication failure: possible replay
[123.457089] ivshmem: authentication failure: tag mismatch
[123.457345] ivshmem: handshake failed: invalid certificate
[123.457512] ivshmem: malformed handshake message
\end{verbatim}

Together, these experiments and their quantitative results—block rates,
latencies, and clear log evidence—demonstrate that our protocol reliably
enforces each security property under active adversarial conditions.

% -------------------

\section{Conclusion}

hello

% -------------------

\section*{Acknowledgment}

The preferred spelling of the word ``acknowledgment'' in America is without an
``e'' after the ``g''. Avoid the stilted expression ``one of us (R. B. G.)
thanks $\ldots$''. Instead, try ``R. B. G. thanks$\ldots$''. Put sponsor
acknowledgments in the unnumbered footnote on the first page.

% \section*{References}

% Please number citations consecutively within brackets \cite{b1}. The 
% sentence punctuation follows the bracket \cite{b2}. Refer simply to the reference 
% number, as in \cite{b3}---do not use ``Ref. \cite{b3}'' or ``reference \cite{b3}'' except at 
% the beginning of a sentence: ``Reference \cite{b3} was the first $\ldots$''

% Number footnotes separately in superscripts. Place the actual footnote at 
% the bottom of the column in which it was cited. Do not put footnotes in the 
% abstract or reference list. Use letters for table footnotes.

% Unless there are six authors or more give all authors' names; do not use 
% ``et al.''. Papers that have not been published, even if they have been 
% submitted for publication, should be cited as ``unpublished'' \cite{b4}. Papers 
% that have been accepted for publication should be cited as ``in press'' \cite{b5}. 
% Capitalize only the first word in a paper title, except for proper nouns and 
% element symbols.

% For papers published in translation journals, please give the English 
% citation first, followed by the original foreign-language citation \cite{b6}.

% \begin{thebibliography}{00}
% \bibitem{b1} G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,'' Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.
% \bibitem{b2} J. Clerk Maxwell, A Treatise on Electricity and Magnetism, 3rd ed., vol. 2. Oxford: Clarendon, 1892, pp.68--73.
% \bibitem{b3} I. S. Jacobs and C. P. Bean, ``Fine particles, thin films and exchange anisotropy,'' in Magnetism, vol. III, G. T. Rado and H. Suhl, Eds. New York: Academic, 1963, pp. 271--350.
% \bibitem{b4} K. Elissa, ``Title of paper if known,'' unpublished.
% \bibitem{b5} R. Nicole, ``Title of paper with only first word capitalized,'' J. Name Stand. Abbrev., in press.
% \bibitem{b6} Y. Yorozu, M. Hirano, K. Oka, and Y. Tagawa, ``Electron spectroscopy studies on magneto-optical media and plastic substrate interface,'' IEEE Transl. J. Magn. Japan, vol. 2, pp. 740--741, August 1987 [Digests 9th Annual Conf. Magnetics Japan, p. 301, 1982].
% \bibitem{b7} M. Young, The Technical Writer's Handbook. Mill Valley, CA: University Science, 1989.
% \bibitem{b8} D. P. Kingma and M. Welling, ``Auto-encoding variational Bayes,'' 2013, arXiv:1312.6114. [Online]. Available: https://arxiv.org/abs/1312.6114
% \bibitem{b9} S. Liu, ``Wi-Fi Energy Detection Testbed (12MTC),'' 2023, gitHub repository. [Online]. Available: https://github.com/liustone99/Wi-Fi-Energy-Detection-Testbed-12MTC
% \bibitem{b10} ``Treatment episode data set: discharges (TEDS-D): concatenated, 2006 to 2009.'' U.S. Department of Health and Human Services, Substance Abuse and Mental Health Services Administration, Office of Applied Studies, August, 2013, DOI:10.3886/ICPSR30122.v2
% \bibitem{b11} K. Eves and J. Valasek, ``Adaptive control for singularly perturbed systems examples,'' Code Ocean, Aug. 2023. [Online]. Available: https://codeocean.com/capsule/4989235/tree
% \end{thebibliography}

\vspace{12pt}

\end{document}